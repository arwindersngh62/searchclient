def new_func():
    new_var = """            agent_ordering = [None for x in self.level.agents]
            for agent in self.level.agents:
                agent_ordering[ord(agent.name)-ord('0')] = agent
            self.joint_action = []
            agents_left = len(agent_ordering)
            while agents_left>0:
                joint_step=[]
                for agent in agent_ordering:
                    if agent.has_next_action():
                        action = agent.actions.pop()
                    else:
                        action = Action.NoOp
                        agents_left-=1
                    joint_step.append(action)
                self.joint_action.append(joint_step) """
    new_var

new_func()
def plan(self):
        changed_plans = set()
        temp_plan_pool = self.plan_pool.copy()

        for plan in self.plan_pool:
            agent_distance = (None, 9999)
            
            if (agent.plan.priority < plan.priority):
                changed_plans.add(agent.plan)
                agent.plan = plan
                temp_plan_pool.remove(plan)
                break


                
                
    

        for agent in self.agents:
            # Plan, distance, prioirty, path
            assigned_plan = (None, 9999, 0, None)
            for plan in self.plan_pool:
                if (plan.box.color != agent.color):
                    continue
                if (plan.agent != None):
                    continue
                # TODO Set this correctly so agent is not on top of box
                path = self.get_shortest_path(agent.coords, plan.box.coords)
                # Prioritise priority value first
                if plan.priority > assigned_plan[2]:
                    assigned_plan = (plan, len(path), plan.priority, path)
                    continue
                elif plan.priority == assigned_plan[2]:
                    if len(path) < assigned_plan[1]:
                        assigned_plan = (plan, len(path), plan.priority, path)
                else:
                    # Plan is less important
                    continue
            # TODO Set this correctly so agent is not on top of box
            assigned_plan[0].start_coords = path[0]
            assigned_plan[0].end_coords = path[-1]
            assigned_plan[0].agent = agent
            agent.plans.append(assigned_plan[0])
                
    # First we are creating generic plans:
    # E.g. Box -> Goal, no time path is defined yet.
    # Then we find the shortest time path to that plan
    def create_box_to_goal_plans(self):
        for agent in self.level.agents:
            if agent.plan != None:
                if agent.plan.box != None:
                    pass


                    def generate_move_plans(self):
        for agent in self.agents:
            curr_plan = agent.plans[0]
            if (agent.coords != curr_plan.start_coords):
                # create new plan to path
                tempPath = get_shortest_time_path(agent.coords, plan.box.coords, current_time)
                tempPlan = plan(agent=agent, box=current_plan.box, path=path, next_plan=current_plan)
                agent.plans.insert(tempPlan, 0)
                continue
            # check versus other agents plans and create conflict tuples
            otherAgents = self.agents[:]
            otherAgents.pop(agent)
            for otherAgent in otherAgents:
                for otherPlan in otherAgent.plans:
                    if plan.start_time == None:
                        # Cant compare to things when we dont know when it starts
                        continue
                    # This is a list of time coordinates that exists in both paths
                    conflict_set = find_conflicts(current_plan.path, otherPlan.path)
                    if (len(conflict_set) > 0):
                        # TODO Deal with conflict
                        # TODO alternative path
                        # TODO Waiting on path
                        pass
                    elif (len(conflict_set) == 0):
                        # No conflicts means its all good
                        non_conflicting_plans.add((current_plan, otherPlan))
                    else:
                        # Some other logic here
                        pass

                                # for plan in self.plan_pool:
        #     # Agent, distance value, path
        #     closest_agent = (none, 9999, none)
        #     for agent in self.level.agents:
        #         if agent.color != plan.box.color:
        #             continue
        #         path = get_shortest_path(agent.coords, box.coords)
        #         if len(dist) > closest_agent[1]:
        #             closest_agent = (agent, len(path), path)
        #     plan.agent, plan.length, plan.path = closest_agent